\chapter{NetCDF and ESDM Functionalities}

\tab
This chapter compares the NetCDF functionalities with the current version of ESDM.

\section{Error Handling}

\tab

\begin{framed}
Each netCDF function in the C, Fortran 77, and Fortran 90 APIs returns 0 on success, in the tradition of C.

NetCDF Error Handling.

When programming with netCDF in these languages, always check return values of every netCDF API call. The return code can be looked up in netcdf.h (for C programmers) or netcdf.inc (for Fortran programmers), or you can use the strerror function to print out an error message. (See nc\_strerror/NF\_STRERROR/NF90\_STRERROR).

In general, if a function returns an error code, you can assume it didn't do what you hoped it would. The exception is the NC\_ERANGE error, which is returned by any of the reading or writing functions when one or more of the values read or written exceeded the range for the type. (For example if you were to try to read 1000 into an unsigned byte.)

In the case of NC\_ERANGE errors, the netCDF library completes the read/write operation, and then returns the error. The type conversion is handled like a C type conversion, whether or not it is within range. This may yield bad data, but the netCDF library just returns NC\_ERANGE and leaves it up to the user to handle. (For more information about type conversion see Type Conversion).

NetCDF functions return a non-zero status codes on error.

Each netCDF function returns an integer status value. If the returned status value indicates an error, you may handle it in any way desired, from printing an associated error message and exiting to ignoring the error indication and proceeding (not recommended!). For simplicity, the examples in this guide check the error status and call a separate function, handle\_err(), to handle any errors. One possible definition of handle\_err() can be found within the documentation of nc\_strerror().

The nc\_strerror() function is available to convert a returned integer error status into an error message string.

Occasionally, low-level I/O errors may occur in a layer below the netCDF library. For example, if a write operation causes you to exceed disk quotas or to attempt to write to a device that is no longer available, you may get an error from a layer below the netCDF library, but the resulting write error will still be reflected in the returned status value.

\url{https://www.unidata.ucar.edu/software/netcdf/docs/group__error.html#details}

\end{framed}

NetCDF has an extense classification for the possible errors that might happen. ESDM does not share this classification, and it is something that their developers are not considering to include in the final version. This decision does not affect the performance of ESDM, but it was critical when the NetCDF tests were evaluated. NetCDF tests introduce several wrong conditions, and ESDM does not produce the expected error. Because of that, the code in the NetCDF tests that considers invalid parameters as input was removed.

\section{Classic Model}

\tab
\begin{framed}

The Classic Model

The classic netCDF data model consists of variables, dimensions, and attributes. This way of thinking about data was introduced with the very first netCDF release, and is still the core of all netCDF files.

In version 4.0, the netCDF data model has been expanded. See The Enhanced Data Model.

Variables
N-dimensional arrays of data. Variables in netCDF files can be one of six types (char, byte, short, int, float, double).

Dimensions
describe the axes of the data arrays. A dimension has a name and a length. An unlimited dimension has a length that can be expanded at any time, as more data are written to it. NetCDF files can contain at most one unlimited dimension.

Attributes
annotate variables or files with small notes or supplementary metadata. Attributes are always scalar values or 1D arrays, which can be associated with either a variable or the file as a whole. Although there is no enforced limit, the user is expected to keep attributes small.

With netCDF-4, the netCDF data model has been extended, in a backwards compatible way.

The new data model, which is known as the “Common Data Model” is part of an effort here at Unidata to find a common engineering language for the development of scientific data solutions. It contains the variables, dimensions, and attributes of the classic data model, but adds:

groups - A way of hierarchically organizing data, similar to directories in a Unix file system.

user-defined types - The user can now define compound types (like C structures), enumeration types, variable length arrays, and opaque types.

These features may only be used when working with a netCDF-4/HDF5 file. Files created in classic formats cannot support groups or user-defined types.

With netCDF-4/HDF5 files, the user may define groups, which may contain variables, dimensions, and attributes. In this way, a group acts as a container for the classic netCDF dataset. But netCDF-4/HDF5 files can have many groups, organized hierarchically.

Each file begins with at least one group, the root group. The user may then add more groups, receiving a new ncid for each group created.

Since each group functions as a complete netCDF classic dataset, it is possible to have variables with the same name in two or more different groups, within the same netCDF-4/HDF5 data file.

Dimensions have a special scope: they may be seen by all variables in their group, and all descendant groups. This allows the user to define dimensions in a top-level group, and use them in many sub-groups.

Since it may be necessary to write code which works with all types of netCDF data files, we also introduce the ability to create netCDF-4/HDF5 files which follow all the rules of the classic netCDF model. That is, these files are in HDF5, but will not support multiple unlimited dimensions, user-defined types, groups, etc. They act just like a classic netCDF file.

\url{https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_data_model.html}

\end{framed}

NetCDF includes tests with the Classic Model, which ESDM does not support, and it has no intention of doing it.

\section{Modes}

\tab
\begin{framed}
Some tests consider in which mode the file is open. There are two modes associated with accessing a NetCDF file:

\begin{description}

\item[Define Mode] In define mode, dimensions, variables, and new attributes can be created, but variable data cannot be read or written.

\item[Data Mode] In data mode, data can be read or written, and attributes can be changed, but new dimensions, variables, and attributes cannot be created.

\end{description}

\url{https://northstar-www.dartmouth.edu/doc/idl/html_6.2/NetCDF_Data_Modes.html}

\end{framed}

The current version of ESDM does not have restrictions in the modes. Once the file is open, the user can do any modifications s/he wants. Tables \ref{tab_modes_create} amd \ref{tab_modes_open} compares the options for creating and opening a file using NetCDF and ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_CLOBBER & Overwrite existing file &  ESDM\_CLOBBER  (???)     \\ \hline
NC\_NOCLOBBER & Do not overwrite existing file &  ESDM\_NOCLOBBER  (???)      \\ \hline
NC\_SHARE & Limit write caching - netcdf classic files only &  NOT SUPPORTED       \\ \hline
NC\_64BIT\_OFFSET & Create 64-bit offset file &    NOT SUPPORTED     \\ \hline
NC\_64BIT\_DATA  & Create CDF-5 file (alias NC\_CDF5) &   NOT SUPPORTED      \\ \hline
NC\_NETCDF4 & Create netCDF-4/HDF5 file &  NOT SUPPORTED       \\ \hline
NC\_CLASSIC\_MODEL & Enforce netCDF classic mode on netCDF-4/HDF5 files &   NOT SUPPORTED      \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_create} Modes: creating a file.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.8cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_NOWRITE & Open the dataset with read-only access &  ESDM\_MODE\_FLAG\_READ       \\ \hline
NC\_WRITE & Open the dataset with read-write access &  ESDM\_MODE\_FLAG\_WRITE       \\ \hline
NC\_SHARE & Share updates, limit caching &  NOT SUPPORTED       \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_open} Modes: opening a file.}
\end{table}

\section{Data Types}

\tab

\url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html#external_types}

\url{https://www.unidata.ucar.edu/software/netcdf/docs/user_defined_types.html}

\url{https://www.unidata.ucar.edu/software/netcdf/netcdf/netCDF-user-defined-data-types.html}

ESDM supports the same basic types that NetCDF. The correspondence between the data types are provided in Table \ref{basic-datatypes-netcdf}.

\begin{comment}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|l|}
\hline
NetCDF TYPE & Number (Value?) & ESDM Type & ESDM Representation \\ \hline \hline
NC\_BYTE       &  1   & SMD\_DTYPE\_INT8     & int8\_t    \\ \hline
NC\_UBYTE      &  7   & SMD\_DTYPE\_UINT8    & uint8\_t    \\ \hline
NC\_CHAR       &  2   & SMD\_DTYPE\_CHAR     & char    \\ \hline
NC\_SHORT      &  3   & SMD\_DTYPE\_INT16    & int16\_t    \\ \hline
NC\_USHORT     &  8   & SMD\_DTYPE\_UINT16   & uint16\_t    \\ \hline
NC\_INT        &  4   & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
NC\_LONG       &  4   & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
NC\_UINT       &  9   & SMD\_DTYPE\_UINT32   & uint32\_t    \\ \hline
NC\_INT64      &  10  & SMD\_DTYPE\_INT64    & int64\_t    \\ \hline
NC\_UINT64     &  5   & SMD\_DTYPE\_UINT64   & uint64\_t    \\ \hline
NC\_FLOAT      &  11  & SMD\_DTYPE\_FLOAT    & 32 bits    \\ \hline
NC\_DOUBLE     &  6   & SMD\_DTYPE\_DOUBLE   & 64 bits    \\ \hline
\hline
\end{tabular}
\caption{\label{basic-datatypes-size} Equivalence between ESDM and NetCDF4 data types -- Data types sorted by size.}
\end{table}

\end{comment}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|l|}
\hline
Number & NetCDF TYPE & ESDM Type & ESDM Representation \\ \hline \hline
1 & NC\_BYTE       & SMD\_DTYPE\_INT8     & int8\_t    \\ \hline
2 & NC\_CHAR       & SMD\_DTYPE\_CHAR     & char    \\ \hline
3 & NC\_SHORT      & SMD\_DTYPE\_INT16    & int16\_t    \\ \hline
4 & NC\_INT        & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
4 & NC\_LONG       & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
5 & NC\_UINT64     & SMD\_DTYPE\_UINT64   & uint64\_t    \\ \hline
6 & NC\_DOUBLE     & SMD\_DTYPE\_DOUBLE   & 64 bits    \\ \hline
7 & NC\_UBYTE      & SMD\_DTYPE\_UINT8    & uint8\_t    \\ \hline
8 & NC\_USHORT     & SMD\_DTYPE\_UINT16   & uint16\_t    \\ \hline
9 & NC\_UINT       & SMD\_DTYPE\_UINT32   & uint32\_t    \\ \hline
10 & NC\_INT64      & SMD\_DTYPE\_INT64    & int64\_t    \\ \hline
11 & NC\_FLOAT      & SMD\_DTYPE\_FLOAT    & 32 bits    \\ \hline
\hline
\end{tabular}
\caption{\label{basic-datatypes-netcdf} Equivalence between ESDM and NetCDF4 data types.}
\end{table}

\url{https://www.unidata.ucar.edu/software/netcdf/netcdf/netCDF-external-data-types.html}

The current version of ESDM does not support user-defined data types, but the developers intend to support this feature in the final version. Table \ref{datatypes-netcdf} summarizes the available NetCDF data types and the corresponding support from ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.4cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_NAT & NAT = Not A Type (c.f. NaN) &    SMD\_TYPE\_AS\_EXPECTED        \\ \hline
NC\_BYTE & signed 1 byte integer &     SMD\_DTYPE\_INT8        \\ \hline
NC\_CHAR & ISO/ASCII character &      SMD\_DTYPE\_CHAR       \\ \hline
NC\_SHORT & signed 2 byte integer &   SMD\_DTYPE\_INT16          \\ \hline
NC\_INT & signed 4 byte integer &     SMD\_DTYPE\_INT32        \\ \hline
NC\_LONG & deprecated, but required for backward compatibility &    SMD\_DTYPE\_INT32         \\ \hline
NC\_FLOAT & single precision floating point number &   SMD\_DTYPE\_FLOAT           \\ \hline
NC\_DOUBLE & double precision floating point number &   SMD\_DTYPE\_DOUBLE          \\ \hline
NC\_UBYTE & unsigned 1 byte int &     SMD\_DTYPE\_UINT8        \\ \hline
NC\_USHORT & unsigned 2-byte int &    SMD\_DTYPE\_UINT16         \\ \hline
NC\_UINT & unsigned 4-byte int &   SMD\_DTYPE\_UINT32          \\ \hline
NC\_INT64 & signed 8-byte int &    SMD\_DTYPE\_INT64         \\ \hline
NC\_UINT64 & unsigned 8-byte int &    SMD\_DTYPE\_UINT64         \\ \hline
NC\_STRING & string &    SMD\_DTYPE\_STRING         \\ \hline
NC\_VLEN & used internally for vlen types &      NOT SUPPORTED YET       \\ \hline
NC\_OPAQUE & used internally for opaque types &     NOT SUPPORTED YET        \\ \hline
NC\_COMPOUND & used internally for compound types &    NOT SUPPORTED YET         \\ \hline
NC\_ENUM & used internally for enum types &       NOT SUPPORTED YET      \\ \hline \hline
\end{tabular}
\caption{\label{datatypes-netcdf} Data Types Support.}
\end{table}

\section{Compression}

\tab

\url{https://www.unidata.ucar.edu/blogs/developer/entry/netcdf_compression}

ESDM does not support compression yet. Because of that, all functions and tests related to chunking, deflate, and fletcher will not work when using ESDM. There is a compression library read to be used, but it was not yet integrated with the current version of ESDM. The Scientific Compression Library (SCIL) can be found in the following Git Repository:

\begin{center}
\url{https://github.com/JulianKunkel/scil/}
\end{center}

\section{Endianness}

\tab
\begin{framed}

The endianness is defined as the order of bytes in multi-byte numbers: numbers encoded in big endian have their most significant bytes written first, whereas numbers encoded in little endian have their least significant bytes first. Little-endian is the native endianness of the IA32 architecture and its derivatives, while big-endian is native to SPARC and PowerPC, among others.

\url{https://www.gnu.org/software/guile/manual/html_node/Bytevector-Endianness.html#FOOT10}

\end{framed}

ESDM only supports native-endianness of the machine it runs on.

\section{Groups}

\tab
\begin{framed}

NetCDF-4 files can store attributes, variables, and dimensions in hierarchical groups.

This allows the user to create a structure much like a Unix file system. In netCDF, each group gets an ncid. Opening or creating a file returns the ncid for the root group (which is named /).

Dimensions are scoped such that they are visible to all child groups. For example, you can define a dimension in the root group, and use its dimension id when defining a variable in a sub-group.

Attributes defined as NC\_GLOBAL apply to the group, not the entire file.

The degenerate case, in which only the root group is used, corresponds exactly with the classic data mode, before groups were introduced.

\url{https://www.unidata.ucar.edu/software/netcdf/docs/groups.html}

\end{framed}

In general, ESDM does not support groups from NetCDF. When only the root group is used, ESDM can work adequately and assumes the group and the file are the same entity. When there are more than one group or subgroups, ESDM can be called using the following command-line interface:

???

The ability to work with groups is a functionality that ESDM developers intend to have in its final version.

\section{Fill Values}

\tab
\begin{framed}

Sometimes there are missing values in the data, and some value is needed to represent them.

For example, what value do you put in a sea-surface temperature variable for points over land?

In netCDF, you can create an attribute for the variable (and of the same type as the variable) called \_FillValue that contains a value that you have used for missing data. Applications that read the data file can use this to know how to represent these values.

Using attributes it is possible to capture metadata that would otherwise be separated from the data. Various conventions have been established. By using a set of conventions, a data producer is more likely to produce files that can be easily shared within the research community, and that contain enough details to be useful as a long-term archive. Conventions also make it easier to develop software that interprets information represented in data, because a convention selects one conventional way to represent information when multiple equivalent representations are possible.

\url{https://www.unidata.ucar.edu/software/netcdf/docs/fill_values.html}

\end{framed}

\section{Conversion}

\begin{framed}

Type Conversion

Each netCDF variable has an external type, specified when the variable is first defined. This external type determines whether the data is intended for text or numeric values, and if numeric, the range and precision of numeric values.

If the netCDF external type for a variable is char, only character data representing text strings can be written to or read from the variable. No automatic conversion of text data to a different representation is supported.

If the type is numeric, however, the netCDF library allows you to access the variable data as a different type and provides automatic conversion between the numeric data in memory and the data in the netCDF variable. For example, if you write a program that deals with all numeric data as double-precision floating point values, you can read netCDF data into double-precision arrays without knowing or caring what the external type of the netCDF variables are. On reading netCDF data, integers of various sizes and single-precision floating-point values will all be converted to double-precision, if you use the data access interface for double-precision values. Of course, you can avoid automatic numeric conversion by using the netCDF interface for a value type that corresponds to the external data type of each netCDF variable, where such value types exist.

The automatic numeric conversions performed by netCDF are easy to understand, because they behave just like assignment of data of one type to a variable of a different type. For example, if you read floating-point netCDF data as integers, the result is truncated towards zero, just as it would be if you assigned a floating-point value to an integer variable. Such truncation is an example of the loss of precision that can occur in numeric conversions.

Converting from one numeric type to another may result in an error if the target type is not capable of representing the converted value. For example, an integer may not be able to hold data stored externally as an IEEE floating-point number. When accessing an array of values, a range error is returned if one or more values are out of the range of representable values, but other values are converted properly.

Note that mere loss of precision in type conversion does not result in an error. For example, if you read double precision values into an integer, no error results unless the magnitude of the double precision value exceeds the representable range of integers on your platform. Similarly, if you read a large integer into a float incapable of representing all the bits of the integer in its mantissa, this loss of precision will not result in an error. If you want to avoid such precision loss, check the external types of the variables you access to make sure you use an internal type that has a compatible precision.

Whether a range error occurs in writing a large floating-point value near the boundary of representable values may be depend on the platform. The largest floating-point value you can write to a netCDF float variable is the largest floating-point number representable on your system that is less than 2 to the 128th power. The largest double precision value you can write to a double variable is the largest double-precision number representable on your system that is less than 2 to the 1024th power.

The \_uchar and \_schar functions were introduced in netCDF-3 to eliminate an ambiguity, and support both signed and unsigned byte data. In netCDF-2, whether the external NC\_BYTE type represented signed or unsigned values was left up to the user. In netcdf-3, we treat NC\_BYTE as signed for the purposes of conversion to short, int, long, float, or double. (Of course, no conversion takes place when the internal type is signed char.) In the \_uchar functions, we treat NC\_BYTE as if it were unsigned. Thus, no NC\_ERANGE error can occur converting between NC\_BYTE and unsigned char.

\url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}

\url{https://www.unidata.ucar.edu/software/netcdf/netcdf/Type-Conversion.html}

\end{framed}

\url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}

\begin{comment}

About conversion...

Actually that is what happens:
      if (nc_def_var(ncid, VAR1_NAME, NC_BYTE, 1, dimids, &varid)) ERR;
      if (nc_enddef(ncid)) ERR;
      if (nc_put_var_uchar(ncid, varid, uchar_out) != NC_ERANGE) ERR;

I found this in the documentation:
> BUT netcdf library returns NC_BYTE data as 8-bit signed
> integers (instead of 8-bit unsigned integers)
> so that NC_BYTE values go from 0 to 127 and then from -128 to -1
> instead of going from 0 to 255 as wanted.

That explains it, right?
https://www.unidata.ucar.edu/software/netcdf/docs_rc/group__variables.html#gac6e82a7c808f1e3c895616415ffa8e5d

The shit function assumes we convert the variable data *on the fly* while writing to the file…

As we are not converting the data type or anything here, we are not supporting this.
I reckon, we should check for any function which NC type does not match our expected type, write an error and abort.
I’m not intending to support this (ever)...

LR. Was this not the point of having the conversion inside smd? At least between the types we support? I also checked something in the documentation and they don’t do it between char and numbers.

The difference is that one is for ATTRIBUTES and one for VARIABLES, SMD is not involved in VARIABLES and hopefully never be as this is a performance problem.
We *might* be able to do part of this, in case COMPRESSION is turned on, as we then have to do a conversion anyway!
Document it this way.

\end{comment}

\begin{comment}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
NetCDF ERROR                  &  Description                                                                        & ESDM ERROR \\ \hline\hline
NC\_EBADDIM                   &  Invalid dimension id or name.                                                      &      \\ \hline
NC\_EBADNAME                  &  Attribute or variable name contains illegal characters.                            &      \\ \hline
NC\_EHDFERR                   &  Error at HDF5 layer.                                                               &      \\ \hline
NC\_EINDEFINE                 &  Operation not allowed in define mode.                                              &      \\ \hline
NC\_EINVAL                    &  Invalid Argument.                                                                  &      \\ \hline
NC\_ELATEFILL                 &  Attempt to define fill value when data already exists.                             &      \\ \hline
NC\_ENOTINDEFINE              &  Operation not allowed in data mode.                                                &      \\ \hline
NC\_ENOTVAR                   &  Variable not found.                                                                &      \\ \hline
NC\_EPERM                     &  Write to read only.                                                                &      \\ \hline
NC\_ERANGE                    &  Math result not representable.                                                     &      \\ \hline
NC\_FILL\_FLOAT               &  Default fill value.                                                                &      \\ \hline
NC\_FORMAT\_64BIT\_OFFSET     &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_CLASSIC           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4\_CLASSIC  &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
\hline
\end{tabular}
\caption{Conversion between ESDM and NetCDF4 Errors.}
\end{table}

\end{comment}

\chapter{Python tests}

Path: esiwace/esdm-netcdf/dev/netcdf4-python/test

\section{Test tst\_atts.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.VariablesTestCase)
testing attributes
----------------------------------------------------------------------
Traceback (most recent call last):
  File "netCDF4/_netCDF4.pyx", line 1449, in netCDF4._netCDF4._get_att
KeyError: 0

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "netCDF4/_netCDF4.pyx", line 1454, in netCDF4._netCDF4._get_att
  File "netCDF4/_netCDF4.pyx", line 5732, in netCDF4._netCDF4._read_compound
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Not a valid data type or _FillValue type mismatch

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "netCDF4/_netCDF4.pyx", line 1459, in netCDF4._netCDF4._get_att
  File "netCDF4/_netCDF4.pyx", line 6019, in netCDF4._netCDF4._read_enum
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Not a valid data type or _FillValue type mismatch

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "tst_atts.py", line 73, in setUp
    v._FillValue(-999.)
  File "netCDF4/_netCDF4.pyx", line 4363, in netCDF4._netCDF4.Variable.__getattr__
  File "netCDF4/_netCDF4.pyx", line 4169, in netCDF4._netCDF4.Variable.getncattr
  File "netCDF4/_netCDF4.pyx", line 1462, in netCDF4._netCDF4._get_att
KeyError: "attribute b'_FillValue' has unsupported datatype"

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_cdf5.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25725c0 "scale_factor",
    datatypep=0x7fffffffb16c, lenp=0x7fffffffb1e8) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_compound\_alignment.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_compound():2220. ESDM does not support user-defined datatypes from NetCDF!
\end{verbatim}

\section{Test tst\_compoundatt.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_grp():2167. ESDM does not support groups from NetCDF!
\end{verbatim}

\section{Test tst\_compoundvar.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_grp():2167. ESDM does not support groups from NetCDF!
\end{verbatim}

\section{Test tst\_compression.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25725c0 "scale_factor",
    datatypep=0x7fffffffb16c, lenp=0x7fffffffb1e8) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_create\_mem.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_dap.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.DapTestCase)
testing access of data over http using opendap
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst_dap.py", line 23, in runTest
    ncfile = netCDF4.Dataset(URL)
  File "netCDF4/_netCDF4.pyx", line 2326, in netCDF4._netCDF4.Dataset.__init__
  File "netCDF4/_netCDF4.pyx", line 1890, in netCDF4._netCDF4._ensure_nc_success
OSError: [Errno -51] NetCDF: Unknown file format: b'http://remotetest.unidata.ucar.edu/thredds/dodsC/testdods/testData.nc'

----------------------------------------------------------------------

\end{verbatim}

\section{Test tst\_dims.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.DimensionsTestCase)
testing dimensions
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst_dims.py", line 38, in setUp
    g.createDimension(LAT_NAME,LAT_LENG)
  File "netCDF4/_netCDF4.pyx", line 2567, in netCDF4._netCDF4.Dataset.createDimension
  File "netCDF4/_netCDF4.pyx", line 3373, in netCDF4._netCDF4.Dimension.__init__
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Not a valid ID

----------------------------------------------------------------------

\end{verbatim}

\section{Test tst\_diskless.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=131072, varid=0, name=0x7ffff25725f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_endian.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5af854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff61ee650 "scale_factor",
    datatypep=0x7fffffffb29c, lenp=0x7fffffffb318) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_enum.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_enum():2316. ESDM does not support user-defined datatypes from NetCDF!
\end{verbatim}

\section{Test tst\_fancyslicing.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5b3854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff61efc80 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_filepath.py}

\begin{verbatim}
======================================================================
ERROR: test_filepath (__main__.test_filepath)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_filepath.py", line 14, in test_filepath
    assert self.nc.filepath() == str(self.netcdf_file)
  File "netCDF4/_netCDF4.pyx", line 2418, in netCDF4._netCDF4.Dataset.filepath
ValueError:
filepath method not enabled.  To enable, install Cython, make sure you have
version 4.1.2 or higher of the netcdf C lib, and rebuild netcdf4-python.

======================================================================
ERROR: test_filepath_with_non_ascii_characters (__main__.test_filepath)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_filepath.py", line 21, in test_filepath_with_non_ascii_characters
    filepatho = nc.filepath(encoding='cp1252')
  File "netCDF4/_netCDF4.pyx", line 2418, in netCDF4._netCDF4.Dataset.filepath
ValueError:
filepath method not enabled.  To enable, install Cython, make sure you have
version 4.1.2 or higher of the netcdf C lib, and rebuild netcdf4-python.
----------------------------------------------------------------------

\end{verbatim}

\section{Test tst\_get\_variables\_by\_attributes.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_grps.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_grp():2167. ESDM does not support groups from NetCDF!
\end{verbatim}

\section{Test tst\_grps2.py}

\begin{verbatim}
[ESDM NC] WARN ESDM_def_grp():2167. ESDM does not support groups from NetCDF!
\end{verbatim}

\section{Test tst\_issue908.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_masked.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25735f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_masked2.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7fffe403c0b0 "_Unsigned", datatypep=0x7fffffffb32c,
    lenp=0x7fffffffb3a8) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_masked3.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=131072, varid=0, name=0x7ffff25715f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_masked4.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25725f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_masked5.py}

\begin{verbatim}
======================================================================
ERROR: test_scaled (__main__.VectorMissingValues)
Testing auto-conversion of masked arrays
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_masked5.py", line 27, in setUp
    v2 = f.createVariable('v2',str,'x',fill_value=u'<missing>')
  File "netCDF4/_netCDF4.pyx", line 2773, in netCDF4._netCDF4.Dataset.createVariable
  File "netCDF4/_netCDF4.pyx", line 3742, in netCDF4._netCDF4.Variable.__init__
ValueError: Variable length strings are only supported for the NETCDF4 format. For other formats, consider using netCDF4.stringtochar to convert string arrays into character arrays with an additional dimension.
----------------------------------------------------------------------

\end{verbatim}

\section{Test tst\_masked6.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=131072, varid=0, name=0x7ffff25715f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_multifile.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5af854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7fffe4056500 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_multifile2.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5b3854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7fffe4055620 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_netcdftime.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1bf154e in ESDM_inq_att (ncid=65536, varid=0, name=0x7fffee9c61a0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_open\_mem.py}

\begin{verbatim}
======================================================================
ERROR: test_mem_open (__main__.TestOpenMem)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_open_mem.py", line 27, in test_mem_open
    print(nc.filepath())
  File "netCDF4/_netCDF4.pyx", line 2418, in netCDF4._netCDF4.Dataset.filepath
ValueError:
filepath method not enabled.  To enable, install Cython, make sure you have
version 4.1.2 or higher of the netcdf C lib, and rebuild netcdf4-python.

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_refcount.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.RefCountTestCase)
testing garbage collection (issue 218)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_refcount.py", line 16, in tearDown
    os.remove(self.file)
FileNotFoundError: [Errno 2] No such file or directory: 'esdm://testfile19663'

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_rename.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.VariablesTestCase)
testing renaming of dimensions, variables and attribute deletion
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_rename.py", line 35, in setUp
    g = f.createGroup(GROUP_NAME2)
  File "netCDF4/_netCDF4.pyx", line 2826, in netCDF4._netCDF4.Dataset.createGroup
  File "netCDF4/_netCDF4.pyx", line 3266, in netCDF4._netCDF4.Group.__init__
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Access failure

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_scalarvar.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25735c0 "add_offset", datatypep=0x7fffffffb3dc,
    lenp=0x7fffffffb458) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_scaled.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=131072, varid=0, name=0x7ffff25735f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_shape.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5b3854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7fffe40380b0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_slicing.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff5a7854e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff61ef650 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_stringarr.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_types.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25715f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_unicode.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.UnicodeTestCase)
testing unicode
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_unicode.py", line 21, in setUp
    v = f.createVariable(VAR_NAME, np.float, (DIM_NAME,))
  File "netCDF4/_netCDF4.pyx", line 2773, in netCDF4._netCDF4.Dataset.createVariable
  File "netCDF4/_netCDF4.pyx", line 3810, in netCDF4._netCDF4.Variable.__init__
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Access failure

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_unicode3.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.UnicodeTestCase)
testing unicode
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_unicode3.py", line 21, in setUp
    v = f.createVariable(VAR_NAME, np.float, (DIM_NAME,))
  File "netCDF4/_netCDF4.pyx", line 2773, in netCDF4._netCDF4.Dataset.createVariable
  File "netCDF4/_netCDF4.pyx", line 3810, in netCDF4._netCDF4.Variable.__init__
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Access failure

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_unicodeatt.py}

\begin{verbatim}
Segmentation fault (core dumped)

Thread 1 "python3" received signal SIGSEGV, Segmentation fault.
__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:93
93	../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.

---Type <return> to continue, or q <return> to quit---
#113 0x00000000004b0de0 in main (argc=2, argv=0x7fffffffe018) at ../Programs/python.c:69
(gdb)
\end{verbatim}

\section{Test tst\_unlimdim.py}

\begin{verbatim}
Segmentation fault (core dumped)

0x00007ffff1f2454e in ESDM_inq_att (ncid=65536, varid=0, name=0x7ffff25715f0 "scale_factor",
    datatypep=0x7fffffffb48c, lenp=0x7fffffffb508) at ../../libsrcesdm/esdm_dispatch.c:1112
1112	    if (a->type->type == SMD_TYPE_ARRAY)
\end{verbatim}

\section{Test tst\_Unsigned.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_utils.py}

\begin{verbatim}
OK
\end{verbatim}

\section{Test tst\_vars.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.VariablesTestCase)
testing primitive variables
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_vars.py", line 37, in setUp
    g = f.createGroup(GROUP_NAME)
  File "netCDF4/_netCDF4.pyx", line 2826, in netCDF4._netCDF4.Dataset.createGroup
  File "netCDF4/_netCDF4.pyx", line 3266, in netCDF4._netCDF4.Group.__init__
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Access failure

----------------------------------------------------------------------
\end{verbatim}

\section{Test tst\_vlen.py}

\begin{verbatim}
======================================================================
ERROR: runTest (__main__.VlenAppendTestCase)
testing appending to vlen variables (issue #527).
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tst\_vlen.py", line 168, in setUp
    vlen_type = f.createVLType(np.float64, 'vltest')
  File "netCDF4/_netCDF4.pyx", line 2621, in netCDF4._netCDF4.Dataset.createVLType
  File "netCDF4/_netCDF4.pyx", line 5835, in netCDF4._netCDF4.VLType.__init__
  File "netCDF4/_netCDF4.pyx", line 5880, in netCDF4._netCDF4._def_vlen
  File "netCDF4/_netCDF4.pyx", line 1892, in netCDF4._netCDF4._ensure_nc_success
RuntimeError: NetCDF: Access failure

----------------------------------------------------------------------
\end{verbatim}

\chapter{netcdf-bench}

Path: esiwace/esdm-netcdf/libsrcesdm\_test/netcdf-bench

\begin{verbatim}
./prepare.sh

./run-test.sh

ln -s _esdm.conf esdm.conf

mkfs.esdm -g --create

mkfs.esdm -l --create
\end{verbatim}

\begin{verbatim}
./benchtool -f=esdm://testfile -F=1

Benchtool (datatype: int)
DEBUG [0]          main.c:364   dgeom (100:100:100:10)
DEBUG [0]          main.c:365   bgeom (1:100:100:10)
DEBUG [0]          main.c:369   (nn 1, ppn 1)
DEBUG [0]          main.c:370   test filename esdm://testfile
Data geometry (t:x:y:z x sizeof(type))     100:100:100:10 x 4 bytes
Block geometry (t:x:y:z x sizeof(type))      1:100:100:10 x 4 bytes
Datasize                                             40000000 bytes                (40.0 MB)
Blocksize                                              400000 bytes                (400.0 kB)
I/O Access                                        independent
Storage                                            contiguous
File length                                             fixed
Fill value                                                yes
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
0 = 100
1 = 100
2 = 100
3 = 10
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START

                                                                               min                  avg                  max
benchmark:write      Open time                                        0.0018334580         0.0018334580         0.0018334580 secs
benchmark:write      I/O time                                         0.0652808010         0.0652808010         0.0652808010 secs
benchmark:write      Close time                                       0.0004117420         0.0004117420         0.0004117420 secs
benchmark:write      I/O Performance (w/o open/close)               584.3520923750       584.3520923750       584.3520923750 MiB/s
benchmark:write      I/O Performance                                564.9227274190       564.9227274190       564.9227274190 MiB/s
DEBUG [0]        report.c:362   REPORT_END

ESDM has not been shutdown correctly. Stacktrace:
3: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xee) [0x7f1a4b837b9e]
4: ./benchtool(_start+0x2a) [0x55b91b68ce6a]
\end{verbatim}

\begin{verbatim}
./benchtool -f=esdm://testfile

Benchtool (datatype: int)
DEBUG [0]          main.c:364   dgeom (100:100:100:10)
DEBUG [0]          main.c:365   bgeom (1:100:100:10)
DEBUG [0]          main.c:369   (nn 1, ppn 1)
DEBUG [0]          main.c:370   test filename esdm://testfile
Data geometry (t:x:y:z x sizeof(type))     100:100:100:10 x 4 bytes
Block geometry (t:x:y:z x sizeof(type))      1:100:100:10 x 4 bytes
Datasize                                             40000000 bytes                (40.0 MB)
Blocksize                                              400000 bytes                (400.0 kB)
I/O Access                                        independent
Storage                                            contiguous
File length                                             fixed
File value                                                 no
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
0 = 100
1 = 100
2 = 100
3 = 10
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START
                                                                               min                  avg                  max
benchmark:write      Open time                                        0.0017575690         0.0017575690         0.0017575690 secs
benchmark:write      I/O time                                         0.0612307650         0.0612307650         0.0612307650 secs
benchmark:write      Close time                                       0.0006145310         0.0006145310         0.0006145310 secs
benchmark:write      I/O Performance (w/o open/close)               623.0033653140       623.0033653140       623.0033653140 MiB/s
benchmark:write      I/O Performance                                599.7681496880       599.7681496880       599.7681496880 MiB/s
DEBUG [0]        report.c:362   REPORT_END

ESDM has not been shutdown correctly. Stacktrace:
3: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xee) [0x7f29b95bab9e]
4: ./benchtool(_start+0x2a) [0x556502704e6a]
\end{verbatim}

\begin{verbatim}
./benchtool -f=esdm://longtest -w -r

Benchtool (datatype: int)
DEBUG [0]          main.c:364   dgeom (100:100:100:10)
DEBUG [0]          main.c:365   bgeom (1:100:100:10)
DEBUG [0]          main.c:369   (nn 1, ppn 1)
DEBUG [0]          main.c:370   test filename esdm://longtest
Data geometry (t:x:y:z x sizeof(type))     100:100:100:10 x 4 bytes
Block geometry (t:x:y:z x sizeof(type))      1:100:100:10 x 4 bytes
Datasize                                             40000000 bytes                (40.0 MB)
Blocksize                                              400000 bytes                (400.0 kB)
I/O Access                                        independent
Storage                                            contiguous
File length                                             fixed
File value                                                 no
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
0 = 100
1 = 100
2 = 100
3 = 10
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START
                                                                               min                  avg                  max
benchmark:write      Open time                                        0.0021035570         0.0021035570         0.0021035570 secs
benchmark:write      I/O time                                         0.0550000690         0.0550000690         0.0550000690 secs
benchmark:write      Close time                                       0.0005124810         0.0005124810         0.0005124810 secs
benchmark:write      I/O Performance (w/o open/close)               693.5804508943       693.5804508943       693.5804508943 MiB/s
benchmark:write      I/O Performance                                662.0886873884       662.0886873884       662.0886873884 MiB/s
DEBUG [0]        report.c:362   REPORT_END
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START
                                                                               min                  avg                  max
benchmark:read       Open time                                        0.0010185700         0.0010185700         0.0010185700 secs
benchmark:read       I/O time                                         0.0209648240         0.0209648240         0.0209648240 secs
benchmark:read       Close time                                       0.0003341830         0.0003341830         0.0003341830 secs
benchmark:read       I/O Performance (w/o open/close)              1819.5703744858      1819.5703744858      1819.5703744858 MiB/s
benchmark:read       I/O Performance                               1709.2793117792      1709.2793117792      1709.2793117792 MiB/s
DEBUG [0]        report.c:362   REPORT_END

ESDM has not been shutdown correctly. Stacktrace:
3: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xee) [0x7f71e0849b9e]
4: ./benchtool(_start+0x2a) [0x5611f27a1e6a]
\end{verbatim}

\begin{verbatim}
./run-test.sh

#!/bin/bash

./benchtool -f=esdm://longtest -w -r

mpiexec -np 2 ./src/benchtool -f="esdm://test.esdm" -n=1 -p=2

echo "Cleanup"
rm -rf _metadummy _esdm

echo "[OK]"

Benchtool (datatype: int)
DEBUG [0]          main.c:364   dgeom (100:100:100:10)
DEBUG [0]          main.c:365   bgeom (1:100:100:10)
DEBUG [0]          main.c:369   (nn 1, ppn 1)
DEBUG [0]          main.c:370   test filename esdm://longtest
Data geometry (t:x:y:z x sizeof(type))     100:100:100:10 x 4 bytes
Block geometry (t:x:y:z x sizeof(type))      1:100:100:10 x 4 bytes
Datasize                                             40000000 bytes                (40.0 MB)
Blocksize                                              400000 bytes                (400.0 kB)
I/O Access                                        independent
Storage                                            contiguous
File length                                             fixed
File value                                                 no
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
0 = 100
1 = 100
2 = 100
3 = 10
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START
                                                                               min                  avg                  max
benchmark:write      Open time                                        0.0020030390         0.0020030390         0.0020030390 secs
benchmark:write      I/O time                                         0.0648872400         0.0648872400         0.0648872400 secs
benchmark:write      Close time                                       0.0003753280         0.0003753280         0.0003753280 secs
benchmark:write      I/O Performance (w/o open/close)               587.8963669180       587.8963669180       587.8963669180 MiB/s
benchmark:write      I/O Performance                                567.1096174930       567.1096174930       567.1096174930 MiB/s
DEBUG [0]        report.c:362   REPORT_END
DEBUG [0]     benchmark.c:213   OPEN_BENCHMARK
DEBUG [0]     benchmark.c:281   IO_BENCHMARK[0]
DEBUG [0]     benchmark.c:292   RUN offset 0:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 1:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 2:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 3:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 4:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 5:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 6:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 7:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 8:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 9:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 10:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 11:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 12:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 13:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 14:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 15:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 16:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 17:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 18:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 19:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 20:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 21:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 22:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 23:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 24:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 25:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 26:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 27:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 28:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 29:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 30:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 31:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 32:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 33:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 34:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 35:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 36:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 37:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 38:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 39:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 40:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 41:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 42:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 43:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 44:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 45:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 46:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 47:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 48:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 49:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 50:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 51:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 52:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 53:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 54:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 55:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 56:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 57:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 58:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 59:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 60:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 61:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 62:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 63:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 64:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 65:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 66:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 67:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 68:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 69:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 70:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 71:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 72:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 73:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 74:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 75:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 76:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 77:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 78:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 79:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 80:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 81:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 82:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 83:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 84:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 85:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 86:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 87:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 88:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 89:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 90:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 91:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 92:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 93:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 94:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 95:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 96:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 97:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 98:0:0:0
DEBUG [0]     benchmark.c:292   RUN offset 99:0:0:0
DEBUG [0]     benchmark.c:318   CLOSE_BENCHMARK
DEBUG [0]        report.c:326   REPORT_START
                                                                               min                  avg                  max
benchmark:read       Open time                                        0.0008915110         0.0008915110         0.0008915110 secs
benchmark:read       I/O time                                         0.0168951110         0.0168951110         0.0168951110 secs
benchmark:read       Close time                                       0.0004516290         0.0004516290         0.0004516290 secs
benchmark:read       I/O Performance (w/o open/close)              2257.8704962897      2257.8704962897      2257.8704962897 MiB/s
benchmark:read       I/O Performance                               2091.5916039082      2091.5916039082      2091.5916039082 MiB/s
DEBUG [0]        report.c:362   REPORT_END

ESDM has not been shutdown correctly. Stacktrace:
3: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xee) [0x7f8f101e3b9e]
4: ./benchtool(_start+0x2a) [0x56250989ee6a]
--------------------------------------------------------------------------
mpiexec was unable to launch the specified application as it could not access
or execute an executable:

Executable: ./src/benchtool
Node: lucy

while attempting to start process rank 0.
--------------------------------------------------------------------------
2 total processes failed to start
Cleanup
[OK]
\end{verbatim}

\chapter{nccopy}

esiwace/esdm-netcdf/build/ncdump/nccopy

rm -rf \_metadummy/ \_posix1/

mkfs.esdm -g -l --create

nccopy input\_file esdm://output\_file

\begin{verbatim}
lucy@lucy:~/esiwace/esdm-netcdf/build/ncdump$ ncdump smallfile.nc
netcdf smallfile {
dimensions:
	lat = 1 ;
variables:
	float lat(lat) ;
	float lon(lat) ;
	int64 Elevation(lat, lat) ;
data:

 lat = _ ;

 lon = _ ;

 Elevation =
  _ ;
}

ESDM has not been shutdown correctly. Stacktrace:
3: ncdump(+0x86f9) [0x562111c426f9]
4: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f046adb9b97]
5: ncdump(+0x264a) [0x562111c3c64a]

lucy@lucy:~/esiwace/esdm-netcdf/build/ncdump$ .libs/nccopy smallfile.nc esdm://smallfile_out.esdm
0 = 1
0 = 1
0 = 1
0 = 1

ESDM has not been shutdown correctly. Stacktrace:
3: .libs/nccopy(+0x8c18) [0x5649b5b55c18]
4: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f7da6109b97]
5: .libs/nccopy(+0x29ea) [0x5649b5b4f9ea]

lucy@lucy:~/esiwace/esdm-netcdf/build/ncdump/_metadummy/containers$ more smallfile_out.esdm.md
{"Variables":{"type":"o","data":null,"childs":{"_nc_dims":{"type":"q1@m","data":["lat"]},"_nc_sizes":{"type":"q1@i","da
ta":[1]}}},"dsets":[{"name":"lat","id":"eUyIKbbzj9Y0kEpk"},
{"name":"lon","id":"eUyIKbxOPzPXyKqL"},
{"name":"Elevation","id":"eUyIKbrJHZSAAnbt"}]}

lucy@lucy:~/esiwace/esdm-netcdf/build/ncdump/_metadummy/containers$ python -m json.tool smallfile_out.esdm.md
{
    "Variables": {
        "childs": {
            "_nc_dims": {
                "data": [
                    "lat"
                ],
                "type": "q1@m"
            },
            "_nc_sizes": {
                "data": [
                    1
                ],
                "type": "q1@i"
            }
        },
        "data": null,
        "type": "o"
    },
    "dsets": [
        {
            "id": "eUyIKbbzj9Y0kEpk",
            "name": "lat"
        },
        {
            "id": "eUyIKbxOPzPXyKqL",
            "name": "lon"
        },
        {
            "id": "eUyIKbrJHZSAAnbt",
            "name": "Elevation"
        }
    ]
}
\end{verbatim}

\begin{verbatim}
lucy@lucy:~/esiwace/esdm-netcdf/build/ncdump$ .libs/nccopy bigfile.nc esdm://bigfile_out.esdm

ESDM has not been shutdown correctly. Stacktrace:
3: .libs/nccopy(+0x8c18) [0x55a117c9fc18]
4: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f6f430a4b97]
5: .libs/nccopy(+0x29ea) [0x55a117c999ea]
\end{verbatim}

nccopy esdm://input\_file output\_file

\begin{verbatim}


\end{verbatim}

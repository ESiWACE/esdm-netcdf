\chapter{NetCDF and ESDM Functionalities}

\tab
This chapter compares the NetCDF functionalities with the current version of ESDM.

\section{Error Handling}

\tab
Each netCDF function returns 0 on success. In general, if a function returns an error code, you can assume it did not do what you hoped it would. NetCDF functions return a non-zero status codes on error. When programming with netCDF, the return code of every netCDF API call can be looked up in \texttt{netcdf.h} (for C programmers).

Each netCDF function returns an integer status value. If the returned status value indicates an error, you may handle it in any way desired, from printing an associated error message and exiting to ignoring the error indication and proceeding (not recommended!).\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/group__error.html}}

\subsection{ESDM}

\tab
NetCDF has an extense classification for the possible errors that might happen. ESDM does not share this classification, and it is something that their developers are not considering to include in the final version. This decision does not affect the performance of ESDM, but it was critical when the NetCDF tests were evaluated. NetCDF tests introduce several wrong conditions, and ESDM does not produce the expected error. Because of that, the code in the NetCDF tests that considers invalid parameters as input was removed.

\section{Classic Model}

The classic netCDF data model consists of variables, dimensions, and attributes. This way of thinking about data was introduced with the very first netCDF release, and is still the core of all netCDF files.

\begin{description}

\item[Variables] $N$-dimensional arrays of data. Variables in netCDF files can be one of six types (char, byte, short, int, float, double).

\item[Dimensions] describe the axes of the data arrays. A dimension has a name and a length. An unlimited dimension has a length that can be expanded at any time, as more data are written to it. NetCDF files can contain at most one unlimited dimension.

\item[Attributes] annotate variables or files with small notes or supplementary metadata. Attributes are always scalar values or 1D arrays, which can be associated with either a variable or the file as a whole. Although there is no enforced limit, the user is expected to keep attributes small.

\end{description}

With netCDF-4, the netCDF data model has been extended, in a backwards compatible way. The new data model, which is known as the \textbf{Common Data Model} is part of an effort here at Unidata to find a common engineering language for the development of scientific data solutions. It contains the variables, dimensions, and attributes of the classic data model, but adds:

\begin{description}

\item[Groups] A way of hierarchically organizing data, similar to directories in a Unix file system.

\item[User-defined Types] The user can now define compound types (like C structures), enumeration types, variable length arrays, and opaque types.

\end{description}

These features may only be used when working with a netCDF-4/HDF5 file. Files created in classic formats cannot support groups or user-defined types.\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_data_model.html}}

\subsection{ESDM}

\tab
NetCDF includes tests with the Classic Model, which ESDM does not support, and it has no intention of doing it.

\section{Modes}

\tab
Some tests consider in which mode the file is open. There are two modes associated with accessing a NetCDF file:\footnote{Reference: \url{https://northstar-www.dartmouth.edu/doc/idl/html_6.2/NetCDF_Data_Modes.html}}

\begin{description}

\item[Define Mode] In define mode, dimensions, variables, and new attributes can be created, but variable data cannot be read or written.

\item[Data Mode] In data mode, data can be read or written, and attributes can be changed, but new dimensions, variables, and attributes cannot be created.

\end{description}

\subsection{ESDM}

\tab
The current version of ESDM does not have restrictions regarding the modes. Once the file is open, the user can do any modifications s/he wants. Tables \ref{tab_modes_create} amd \ref{tab_modes_open} compares the options for creating and opening a file using NetCDF and ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_CLOBBER & Overwrite existing file &  ESDM\_CLOBBER  (???)     \\ \hline
NC\_NOCLOBBER & Do not overwrite existing file &  ESDM\_NOCLOBBER  (???)      \\ \hline
NC\_SHARE & Limit write caching - netcdf classic files only &  NOT SUPPORTED       \\ \hline
NC\_64BIT\_OFFSET & Create 64-bit offset file &    NOT SUPPORTED     \\ \hline
NC\_64BIT\_DATA  & Create CDF-5 file (alias NC\_CDF5) &   NOT SUPPORTED      \\ \hline
NC\_NETCDF4 & Create netCDF-4/HDF5 file &  NOT SUPPORTED       \\ \hline
NC\_CLASSIC\_MODEL & Enforce netCDF classic mode on netCDF-4/HDF5 files &   NOT SUPPORTED      \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_create} Modes: creating a file.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.8cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_NOWRITE & Open the dataset with read-only access &  ESDM\_MODE\_FLAG\_READ       \\ \hline
NC\_WRITE & Open the dataset with read-write access &  ESDM\_MODE\_FLAG\_WRITE       \\ \hline
NC\_SHARE & Share updates, limit caching &  NOT SUPPORTED       \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_open} Modes: opening a file.}
\end{table}

\section{Data Types}

\tab
Data in a netCDF file may be one of the \textbf{external data types}, or may be a \textbf{user-defined data type}.\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}}

\subsection{External Data Types}

\tab
The atomic external types supported by the netCDF interface are:

\begin{description}

\item[\small NC\_BYTE] 8-bit signed integer
\\item[\small NC\_UBYTE] 8-bit unsigned integer
\\item[\small NC\_CHAR] 8-bit character
\\item[\small NC\_SHORT] 16-bit signed integer
\\item[\small NC\_USHORT] 16-bit unsigned integer
\\item[\small NC\_INT (or NC\_LONG)] 32-bit signed integer
\\item[\small NC\_UINT] 32-bit unsigned integer
\\item[\small NC\_INT64] 64-bit signed integer
\\item[\small NC\_UINT64] 64-bit unsigned integer
\\item[\small NC\_FLOAT] 32-bit floating point
\\item[\small NC\_DOUBLE] 64-bit floating point
\\item[\small NC\_STRING] variable length character string

\end{description}

\subsection{User Defined Types}

\tab
The user can now define compound types (like C structures), enumeration types, variable length arrays, and opaque types\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/user\_defined\_types.html}}.

\begin{description}

\item[Compound Types]

In netCDF-4 files it is possible to create a data type which corresponds to a C struct. These are known as \textbf{compound} types (following HDF5 nomenclature).

That is, a netCDF compound type is a data structure which contains an arbitrary collection of other data types, including other compound types.

To define a new compound type, use \texttt{nc\_def\_compound()}. Then call \texttt{nc\_insert\_compound()} for each type within the compound type.

Read and write arrays of compound data with the \texttt{nc\_get\_vara()} and \texttt{nc\_put\_vara()} functions. These functions were actually part of the netCDF-2 API, brought out of semi-retirement to handle user-defined types in netCDF-4.

\item[Opaque Types]

Store blobs of bits in opaque types. Create an opaque type with nc\_def\_opaque. Read and write them with \texttt{nc\_get\_vara()}/\texttt{nc\_put\_vara()}.

\item[Variable Length Arrays (VLEN)]

Create a VLEN type to store variable length arrays of a known base type. Use \texttt{nc\_def\_vlen()} to define a VLEN type, read and write them with \texttt{nc\_get\_vara()}/\texttt{nc\_put\_vara()}.

\end{description}

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/netcdf/netCDF-user-defined-data-types.html}}

\subsection{ESDM}

\tab
ESDM supports the same basic types that NetCDF. The correspondence between the data types are provided in Table \ref{basic-datatypes-netcdf}.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|l|}
\hline
Number & NetCDF TYPE & ESDM Type & ESDM Representation \\ \hline \hline
1 & NC\_BYTE       & SMD\_DTYPE\_INT8     & int8\_t    \\ \hline
2 & NC\_CHAR       & SMD\_DTYPE\_CHAR     & char    \\ \hline
3 & NC\_SHORT      & SMD\_DTYPE\_INT16    & int16\_t    \\ \hline
4 & NC\_INT        & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
4 & NC\_LONG       & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
5 & NC\_UINT64     & SMD\_DTYPE\_UINT64   & uint64\_t    \\ \hline
6 & NC\_DOUBLE     & SMD\_DTYPE\_DOUBLE   & 64 bits    \\ \hline
7 & NC\_UBYTE      & SMD\_DTYPE\_UINT8    & uint8\_t    \\ \hline
8 & NC\_USHORT     & SMD\_DTYPE\_UINT16   & uint16\_t    \\ \hline
9 & NC\_UINT       & SMD\_DTYPE\_UINT32   & uint32\_t    \\ \hline
10 & NC\_INT64      & SMD\_DTYPE\_INT64    & int64\_t    \\ \hline
11 & NC\_FLOAT      & SMD\_DTYPE\_FLOAT    & 32 bits    \\ \hline
\hline
\end{tabular}
\caption{\label{basic-datatypes-netcdf} Equivalence between ESDM and NetCDF4 data types.}
\end{table}

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/netcdf/netCDF-external-data-types.html}}

The current version of ESDM does not support user-defined data types, but the developers intend to support this feature in the final version. Table \ref{datatypes-netcdf} summarizes the available NetCDF data types and the corresponding support from ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.4cm}|l|}
\hline
FLAG & NetCDF Support & ESDM Support \\ \hline \hline
NC\_NAT & NAT = Not A Type (c.f. NaN) &    SMD\_TYPE\_AS\_EXPECTED        \\ \hline
NC\_BYTE & signed 1 byte integer &     SMD\_DTYPE\_INT8        \\ \hline
NC\_CHAR & ISO/ASCII character &      SMD\_DTYPE\_CHAR       \\ \hline
NC\_SHORT & signed 2 byte integer &   SMD\_DTYPE\_INT16          \\ \hline
NC\_INT & signed 4 byte integer &     SMD\_DTYPE\_INT32        \\ \hline
NC\_LONG & deprecated, but required for backward compatibility &    SMD\_DTYPE\_INT32         \\ \hline
NC\_FLOAT & single precision floating point number &   SMD\_DTYPE\_FLOAT           \\ \hline
NC\_DOUBLE & double precision floating point number &   SMD\_DTYPE\_DOUBLE          \\ \hline
NC\_UBYTE & unsigned 1 byte int &     SMD\_DTYPE\_UINT8        \\ \hline
NC\_USHORT & unsigned 2-byte int &    SMD\_DTYPE\_UINT16         \\ \hline
NC\_UINT & unsigned 4-byte int &   SMD\_DTYPE\_UINT32          \\ \hline
NC\_INT64 & signed 8-byte int &    SMD\_DTYPE\_INT64         \\ \hline
NC\_UINT64 & unsigned 8-byte int &    SMD\_DTYPE\_UINT64         \\ \hline
NC\_STRING & string &    SMD\_DTYPE\_STRING         \\ \hline
NC\_VLEN & used internally for vlen types &      NOT SUPPORTED YET       \\ \hline
NC\_OPAQUE & used internally for opaque types &     NOT SUPPORTED YET        \\ \hline
NC\_COMPOUND & used internally for compound types &    NOT SUPPORTED YET         \\ \hline
NC\_ENUM & used internally for enum types &       NOT SUPPORTED YET      \\ \hline \hline
\end{tabular}
\caption{\label{datatypes-netcdf} Data Types Support.}
\end{table}

\section{Compression}

\footnote{Reference: \url{https://www.unidata.ucar.edu/blogs/developer/entry/netcdf_compression}}

\subsection{ESDM}

\tab
ESDM does not support compression yet. Because of that, all functions and tests related to chunking, deflate, and fletcher will not work when using ESDM. There is a compression library read to be used, but it was not yet integrated with the current version of ESDM. The Scientific Compression Library (SCIL) can be found in the following Git Repository:

\begin{center}
\url{https://github.com/JulianKunkel/scil/}
\end{center}

\section{Endianness}

\tab
\begin{framed}

The endianness is defined as the order of bytes in multi-byte numbers: numbers encoded in big endian have their most significant bytes written first, whereas numbers encoded in little endian have their least significant bytes first. Little-endian is the native endianness of the IA32 architecture and its derivatives, while big-endian is native to SPARC and PowerPC, among others.

\footnote{Reference: \url{https://www.gnu.org/software/guile/manual/html_node/Bytevector-Endianness.html}}

\end{framed}

\subsection{ESDM}

\tab
ESDM only supports native-endianness of the machine it runs on.

\section{Groups}

\tab
\begin{framed}

NetCDF-4 files can store attributes, variables, and dimensions in hierarchical groups.

This allows the user to create a structure much like a Unix file system. In netCDF, each group gets an ncid. Opening or creating a file returns the ncid for the root group (which is named /).

Dimensions are scoped such that they are visible to all child groups. For example, you can define a dimension in the root group, and use its dimension id when defining a variable in a sub-group.

Attributes defined as NC\_GLOBAL apply to the group, not the entire file.

The degenerate case, in which only the root group is used, corresponds exactly with the classic data mode, before groups were introduced.

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/groups.html}}

\end{framed}

\subsection{ESDM}

\tab
In general, ESDM does not support groups from NetCDF. When only the root group is used, ESDM can work adequately and assumes the group and the file are the same entity. When there are more than one group or subgroups, ESDM can be called using the following command-line interface:

???

The ability to work with groups is a functionality that ESDM developers intend to have in its final version.

\section{Fill Values}

\tab
\begin{framed}

Sometimes there are missing values in the data, and some value is needed to represent them.

For example, what value do you put in a sea-surface temperature variable for points over land?

In netCDF, you can create an attribute for the variable (and of the same type as the variable) called \_FillValue that contains a value that you have used for missing data. Applications that read the data file can use this to know how to represent these values.

Using attributes it is possible to capture metadata that would otherwise be separated from the data. Various conventions have been established. By using a set of conventions, a data producer is more likely to produce files that can be easily shared within the research community, and that contain enough details to be useful as a long-term archive. Conventions also make it easier to develop software that interprets information represented in data, because a convention selects one conventional way to represent information when multiple equivalent representations are possible.

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/fill_values.html}}

\end{framed}

\subsection{ESDM}

\tab
ESDM supports fill values.

\section{Conversion}

\begin{framed}

Type Conversion

Each netCDF variable has an external type, specified when the variable is first defined. This external type determines whether the data is intended for text or numeric values, and if numeric, the range and precision of numeric values.

If the netCDF external type for a variable is char, only character data representing text strings can be written to or read from the variable. No automatic conversion of text data to a different representation is supported.

If the type is numeric, however, the netCDF library allows you to access the variable data as a different type and provides automatic conversion between the numeric data in memory and the data in the netCDF variable. For example, if you write a program that deals with all numeric data as double-precision floating point values, you can read netCDF data into double-precision arrays without knowing or caring what the external type of the netCDF variables are. On reading netCDF data, integers of various sizes and single-precision floating-point values will all be converted to double-precision, if you use the data access interface for double-precision values. Of course, you can avoid automatic numeric conversion by using the netCDF interface for a value type that corresponds to the external data type of each netCDF variable, where such value types exist.

The automatic numeric conversions performed by netCDF are easy to understand, because they behave just like assignment of data of one type to a variable of a different type. For example, if you read floating-point netCDF data as integers, the result is truncated towards zero, just as it would be if you assigned a floating-point value to an integer variable. Such truncation is an example of the loss of precision that can occur in numeric conversions.

Converting from one numeric type to another may result in an error if the target type is not capable of representing the converted value. For example, an integer may not be able to hold data stored externally as an IEEE floating-point number. When accessing an array of values, a range error is returned if one or more values are out of the range of representable values, but other values are converted properly.

Note that mere loss of precision in type conversion does not result in an error. For example, if you read double precision values into an integer, no error results unless the magnitude of the double precision value exceeds the representable range of integers on your platform. Similarly, if you read a large integer into a float incapable of representing all the bits of the integer in its mantissa, this loss of precision will not result in an error. If you want to avoid such precision loss, check the external types of the variables you access to make sure you use an internal type that has a compatible precision.

Whether a range error occurs in writing a large floating-point value near the boundary of representable values may be depend on the platform. The largest floating-point value you can write to a netCDF float variable is the largest floating-point number representable on your system that is less than 2 to the 128th power. The largest double precision value you can write to a double variable is the largest double-precision number representable on your system that is less than 2 to the 1024th power.

The \_uchar and \_schar functions were introduced in netCDF-3 to eliminate an ambiguity, and support both signed and unsigned byte data. In netCDF-2, whether the external NC\_BYTE type represented signed or unsigned values was left up to the user. In netcdf-3, we treat NC\_BYTE as signed for the purposes of conversion to short, int, long, float, or double. (Of course, no conversion takes place when the internal type is signed char.) In the \_uchar functions, we treat NC\_BYTE as if it were unsigned. Thus, no NC\_ERANGE error can occur converting between NC\_BYTE and unsigned char.

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}}

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/netcdf/Type-Conversion.html}}

\end{framed}

\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}}

\subsection{ESDM}

\tab
Tests with ESDM conversion:

\begin{verbatim}

Final Results - INT8 to FLOAT

********************************************
INT8_MAX = 127
Maximum FLOAT = 126.000000
Maximum INT8 = 126
********************************************

********************************************
INT8_MIN = -128
Minimum FLOAT = -127.000000
Minimum INT8 = -127
********************************************

Final Results - INT16 to FLOAT

********************************************
INT16_MAX = 32767
Maximum FLOAT = 32766.000000
Maximum INT16 = 32766
********************************************

********************************************
INT16_MIN = -32768
Minimum FLOAT = -32767.000000
Minimum INT16 = -32767
********************************************

Final Results - INT32 to FLOAT

********************************************
INT32_MAX = 2147483647
Maximum FLOAT = 2147483520.000000
Maximum INT32 = 2147483583
********************************************

********************************************
INT32_MIN = -2147483648
Minimum FLOAT = -2147483520.000000
Maximum INT32 = -2147483583
********************************************

Final Results - INT64 to FLOAT

********************************************
INT64_MAX = 9223372036854775807
Maximum FLOAT = 9223371487098961920.000000
Maximum INT64 = 9223371761976865807
********************************************

********************************************
INT64_MIN = -9223372036854775808
Minimum FLOAT = -9223371487098961920.000000
Minimum INT64 = -9223371761976865808
********************************************

Final Results - UINT8 to FLOAT

********************************************
UINT8_MAX = 255
Maximum FLOAT = 254.000000
Maximum UINT8 = 254
********************************************

Final Results - UINT16 to FLOAT

********************************************
UINT16_MAX = 65535
Maximum FLOAT = 65534.000000
Maximum UINT16 = 65534
********************************************

Final Results - UINT32 to FLOAT

********************************************
UINT32_MAX = 4294967295
Maximum FLOAT = 4294967040.000000
Maximum UINT32 = 4294967167
********************************************

Final Results - UINT64 to FLOAT

********************************************
UINT64_MAX = 18446744073709551615
Maximum FLOAT = 18446742974197923840.000000
Maximum UINT64 = 18446743523953731615
********************************************

Final Results - INT8 to DOUBLE

********************************************
INT8_MAX = 127
Maximum DOUBLE = 126.000000
Maximum INT8 = 126
********************************************

********************************************
INT8_MIN = -128
Minimum DOUBLE = -127.000000
Minimum INT8 = -127
********************************************

Final Results - INT16 to DOUBLE

********************************************
INT16_MAX = 32767
Maximum DOUBLE = 32766.000000
Maximum INT16 = 32766
********************************************

********************************************
INT16_MIN = -32768
Minimum DOUBLE = -32767.000000
Minimum INT16 = -32767
********************************************

Final Results - INT32 to DOUBLE

********************************************
INT32_MAX = 2147483647
Maximum DOUBLE = 2147483646.000000
Maximum INT32 = 2147483646
********************************************

********************************************
INT32_MIN = -2147483648
Minimum DOUBLE = -2147483647.000000
Minimum INT32 = -2147483647
********************************************

Final Results - INT64 to DOUBLE

********************************************
INT64_MAX = 9223372036854775807
Maximum DOUBLE = 9223372036854774784.000000
Maximum INT64 = 9223372036854775295
********************************************

********************************************
INT64_MIN = -9223372036854775808
Minimum DOUBLE = -9223372036854774784.000000
Minimum INT64 = -9223372036854775295
********************************************

Final Results - UINT8 to DOUBLE

********************************************
UINT8_MAX = 255
Maximum DOUBLE = 254.000000
Maximum UINT8 = 254
********************************************

Final Results - UINT16 to DOUBLE

********************************************
UINT16_MAX = 65535
Maximum DOUBLE = 65534.000000
Maximum UINT16 = 65534
********************************************

Final Results - UINT32 to DOUBLE

********************************************
UINT32_MAX = 4294967295
Maximum DOUBLE = 4294967294.000000
Maximum UINT32 = 4294967294
********************************************

Final Results - UINT64 to DOUBLE

********************************************
UINT64_MAX = 18446744073709551615
Maximum DOUBLE = 18446744073709549568.000000
Maximum UINT64 = 18446744073709550591
********************************************

\end{verbatim}

\begin{comment}

About conversion...

Actually that is what happens:
      if (nc_def_var(ncid, VAR1_NAME, NC_BYTE, 1, dimids, &varid)) ERR;
      if (nc_enddef(ncid)) ERR;
      if (nc_put_var_uchar(ncid, varid, uchar_out) != NC_ERANGE) ERR;

I found this in the documentation:
> BUT netcdf library returns NC_BYTE data as 8-bit signed
> integers (instead of 8-bit unsigned integers)
> so that NC_BYTE values go from 0 to 127 and then from -128 to -1
> instead of going from 0 to 255 as wanted.

That explains it, right?
https://www.unidata.ucar.edu/software/netcdf/docs_rc/group__variables.html#gac6e82a7c808f1e3c895616415ffa8e5d

The shit function assumes we convert the variable data *on the fly* while writing to the file…

As we are not converting the data type or anything here, we are not supporting this.
I reckon, we should check for any function which NC type does not match our expected type, write an error and abort.
I’m not intending to support this (ever)...

LR. Was this not the point of having the conversion inside smd? At least between the types we support? I also checked something in the documentation and they don’t do it between char and numbers.

The difference is that one is for ATTRIBUTES and one for VARIABLES, SMD is not involved in VARIABLES and hopefully never be as this is a performance problem.
We *might* be able to do part of this, in case COMPRESSION is turned on, as we then have to do a conversion anyway!
Document it this way.

\end{comment}

\begin{comment}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
NetCDF ERROR                  &  Description                                                                        & ESDM ERROR \\ \hline\hline
NC\_EBADDIM                   &  Invalid dimension id or name.                                                      &      \\ \hline
NC\_EBADNAME                  &  Attribute or variable name contains illegal characters.                            &      \\ \hline
NC\_EHDFERR                   &  Error at HDF5 layer.                                                               &      \\ \hline
NC\_EINDEFINE                 &  Operation not allowed in define mode.                                              &      \\ \hline
NC\_EINVAL                    &  Invalid Argument.                                                                  &      \\ \hline
NC\_ELATEFILL                 &  Attempt to define fill value when data already exists.                             &      \\ \hline
NC\_ENOTINDEFINE              &  Operation not allowed in data mode.                                                &      \\ \hline
NC\_ENOTVAR                   &  Variable not found.                                                                &      \\ \hline
NC\_EPERM                     &  Write to read only.                                                                &      \\ \hline
NC\_ERANGE                    &  Math result not representable.                                                     &      \\ \hline
NC\_FILL\_FLOAT               &  Default fill value.                                                                &      \\ \hline
NC\_FORMAT\_64BIT\_OFFSET     &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_CLASSIC           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4\_CLASSIC  &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
\hline
\end{tabular}
\caption{Conversion between ESDM and NetCDF4 Errors.}
\end{table}

\end{comment}

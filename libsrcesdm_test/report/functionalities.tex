\chapter{NetCDF and ESDM Functionalities}
\label{ch:func}


This chapter compares the NetCDF functionalities with the current version of ESDM.
% This chapter describes the main NetCDF functionalities and their coverage by the current version of ESDM.

\section{Error Handling}


Each NetCDF function returns 0 on success. In general, if a function returns an error code, you can assume it did not do what you hoped it would. NetCDF functions return a non-zero status codes on error. When programming with NetCDF, the return code of every NetCDF API call can be looked up in \texttt{netcdf.h} (for C programmers).

Each NetCDF function returns an integer status value. If the returned status value indicates an error, you may handle it in any way desired, from printing an associated error message and exiting to ignoring the error indication and proceeding (this is not recommended!).\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/group__error.html}}

\subsection{ESDM}


NetCDF has an extense classification for the possible errors that might happen. ESDM does not share this classification, and it is something that their developers are not considering to include in the final version. This decision does not affect the performance of ESDM, but it was critical when the NetCDF tests were evaluated. NetCDF tests introduce several wrong conditions, and ESDM does not produce the expected error. Because of that, the code in the NetCDF tests that considers invalid parameters as input was removed.

\section{Classic Model}

The classic NetCDF data model consists of variables, dimensions, and attributes. This way of thinking about data was introduced with the very first NetCDF release, and is still the core of all NetCDF files.

\begin{description}

\item[Variables] $N$-dimensional arrays of data. Variables in NetCDF files can be one of six types (char, byte, short, int, float, double).

\item[Dimensions] describe the axes of the data arrays. A dimension has a name and a length. An unlimited dimension has a length that can be expanded at any time, as more data are written to it. NetCDF files can contain at most one unlimited dimension.

\item[Attributes] annotate variables or files with small notes or supplementary metadata. Attributes are always scalar values or 1D arrays, which can be associated with either a variable or the file as a whole. Although there is no enforced limit, the user is expected to keep attributes small.

\end{description}

With NetCDF-4, the NetCDF data model has been extended, in a backwards compatible way. The new data model, which is known as the \textbf{Common Data Model} is part of an effort here at Unidata to find a common engineering language for the development of scientific data solutions. It contains the variables, dimensions, and attributes of the classic data model, but adds:

\begin{description}

\item[Groups] A way of hierarchically organizing data, similar to directories in a Unix file system.

\item[User-defined Types] The user can now define compound types (like C structures), enumeration types, variable length arrays, and opaque types.

\end{description}

These features may only be used when working with a NetCDF-4/HDF5 file. Files created in classic formats cannot support groups or user-defined types.\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_data_model.html}}

\subsection{ESDM}


NetCDF includes tests with the Classic Model; while the ESDM data model basically supports all features of the Classic Model, it does not support the setting of the mode.

\section{Modes}


Some tests consider in which mode the file is open. There are two modes associated with accessing a NetCDF file:\footnote{Reference: \url{https://northstar-www.dartmouth.edu/doc/idl/html_6.2/NetCDF_Data_Modes.html}}

\begin{description}

\item[Define Mode] In define mode, dimensions, variables, and new attributes can be created, but variable data cannot be read or written.

\item[Data Mode] In data mode, data can be read or written, and attributes can be changed, but new dimensions, variables, and attributes cannot be created.

\end{description}

\subsection{ESDM}


The current version of ESDM does not have restrictions regarding the modes. Once the file is open, the user can do any modifications s/he wants. Tables \ref{tab_modes_create} amd \ref{tab_modes_open} compares the options for creating and opening a file using NetCDF and ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6cm}|l|}
\hline
\multicolumn{1}{|c|}{FLAG} & \multicolumn{1}{|c|}{NetCDF Support} & \multicolumn{1}{|c|}{ESDM Support} \\ \hline \hline
FLAG & NetCDF Support & ESDM Support\footnote{ESDM maps the NetCDF flag into an internal flag, if it is supported.} \\ \hline \hline
NC\_CLOBBER & Overwrite existing file &  ESDM\_CLOBBER    \\ \hline
NC\_NOCLOBBER & Do not overwrite existing file &  ESDM\_NOCLOBBER      \\ \hline
NC\_SHARE & Limit write caching - netcdf classic files only &  NOT SUPPORTED       \\ \hline
NC\_64BIT\_OFFSET & Create 64-bit offset file &    NOT SUPPORTED     \\ \hline
NC\_64BIT\_DATA  & Create CDF-5 file (alias NC\_CDF5) &   NOT SUPPORTED      \\ \hline
NC\_NETCDF4 & Create NetCDF-4/HDF5 file &  NOT SUPPORTED       \\ \hline
NC\_CLASSIC\_MODEL & Enforce NetCDF classic mode on NetCDF-4/HDF5 files &   NOT SUPPORTED      \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_create} Modes -- Creating a file.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.8cm}|l|}
\hline
\multicolumn{1}{|c|}{FLAG} & \multicolumn{1}{|c|}{NetCDF Support} & \multicolumn{1}{|c|}{ESDM Support} \\ \hline \hline
NC\_NOWRITE & Open the dataset with read-only access &  ESDM\_MODE\_FLAG\_READ       \\ \hline
NC\_WRITE & Open the dataset with read-write access &  ESDM\_MODE\_FLAG\_WRITE       \\ \hline
NC\_SHARE & Share updates, limit caching &  NOT SUPPORTED       \\ \hline
NC\_DISKLESS & Store data in memory &    NOT SUPPORTED     \\ \hline
NC\_PERSIST & Force the NC\_DISKLESS data from memory to a file &  NOT SUPPORTED       \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_open} Modes -- Opening a file.}
\end{table}

\section{Data Types}


Data in a NetCDF file may be one of the \textbf{external data types} (Section \ref{ed-type}), or may be a \textbf{user-defined data type} (Section \ref{ud-type}).\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html}}

\subsection{External Data Types}
\label{ed-type}


The atomic external types supported by the NetCDF interface are:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Type} & \multicolumn{1}{|c|}{Description} \\ \hline \hline
NC\_BYTE & 8-bit signed integer \\ \hline
NC\_UBYTE & 8-bit unsigned integer \\ \hline
NC\_CHAR & 8-bit character \\ \hline
NC\_SHORT & 16-bit signed integer \\ \hline
NC\_USHORT & 16-bit unsigned integer \\ \hline
NC\_INT (or NC\_LONG) & 32-bit signed integer \\ \hline
NC\_UINT & 32-bit unsigned integer \\ \hline
NC\_INT64 & 64-bit signed integer \\ \hline
NC\_UINT64 & 64-bit unsigned integer \\ \hline
NC\_FLOAT & 32-bit floating-point \\ \hline
NC\_DOUBLE & 64-bit floating-point \\ \hline
NC\_STRING & variable length character string \\ \hline
\hline
\end{tabular}
\caption{\label{tab_modes_open} Atomic external types.}
\end{table}

\subsection{User-Defined Types}
\label{ud-type}


The user can now define compound types (like C structures), enumeration types, variable length arrays, and opaque types\footnote{References: \url{https://www.unidata.ucar.edu/software/netcdf/docs/user\_defined\_types.html} and \url{https://www.unidata.ucar.edu/software/netcdf/netcdf/NetCDF-user-defined-data-types.html}}.

\begin{description}

\item[Compound Types]

In NetCDF-4 files it is possible to create a data type which corresponds to a C struct. These are known as \textbf{compound} types (following HDF5 nomenclature).

That is, a NetCDF compound type is a data structure which contains an arbitrary collection of other data types, including other compound types.

To define a new compound type, use \texttt{nc\_def\_compound()}. Then call \texttt{nc\_insert\_compound()} for each type within the compound type.

Read and write arrays of compound data with the \texttt{nc\_get\_vara()} and \texttt{nc\_put\_vara()} functions. These functions were actually part of the NetCDF-2 API, brought out of semi-retirement to handle user-defined types in NetCDF-4.

\item[Opaque Types]

Store blobs of bits in opaque types. Create an opaque type with nc\_def\_opaque. Read and write them with \texttt{nc\_get\_vara()}/\texttt{nc\_put\_vara()}.

\item[Variable Length Arrays (VLEN)]

Create a VLEN type to store variable length arrays of a known base type. Use \texttt{nc\_def\_vlen()} to define a VLEN type, read and write them with \texttt{nc\_get\_vara()}/\texttt{nc\_put\_vara()}.

\end{description}

\subsection{ESDM}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{1}{|c|}{Number} & \multicolumn{1}{|c|}{NetCDF TYPE} & \multicolumn{1}{|c|}{ESDM Type} & \multicolumn{1}{|c|}{ESDM Representation} \\ \hline \hline
1 & NC\_BYTE       & SMD\_DTYPE\_INT8     & int8\_t    \\ \hline
2 & NC\_CHAR       & SMD\_DTYPE\_CHAR     & char    \\ \hline
3 & NC\_SHORT      & SMD\_DTYPE\_INT16    & int16\_t    \\ \hline
4 & NC\_INT        & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
4 & NC\_LONG       & SMD\_DTYPE\_INT32    & int32\_t    \\ \hline
5 & NC\_UINT64     & SMD\_DTYPE\_UINT64   & uint64\_t    \\ \hline
6 & NC\_DOUBLE     & SMD\_DTYPE\_DOUBLE   & 64 bits    \\ \hline
7 & NC\_UBYTE      & SMD\_DTYPE\_UINT8    & uint8\_t    \\ \hline
8 & NC\_USHORT     & SMD\_DTYPE\_UINT16   & uint16\_t    \\ \hline
9 & NC\_UINT       & SMD\_DTYPE\_UINT32   & uint32\_t    \\ \hline
10 & NC\_INT64      & SMD\_DTYPE\_INT64    & int64\_t    \\ \hline
11 & NC\_FLOAT      & SMD\_DTYPE\_FLOAT    & 32 bits    \\ \hline
\hline
\end{tabular}
\caption{\label{basic-datatypes-netcdf} Equivalence between ESDM and NetCDF4 data types.}
\end{table}

The current version of ESDM does not support user-defined data types, but the developers intend to support this feature in the final version. Table \ref{datatypes-netcdf} summarizes the available NetCDF data types and the corresponding support from ESDM.

\begin{table}[H]
\centering
\begin{tabular}{|l|m{6.4cm}|l|}
\hline
\multicolumn{1}{|c|}{FLAG} & \multicolumn{1}{|c|}{NetCDF Support} & \multicolumn{1}{|c|}{ESDM Support} \\ \hline \hline
NC\_NAT & NAT = Not A Type (c.f. NaN) &    SMD\_TYPE\_AS\_EXPECTED        \\ \hline
NC\_BYTE & signed 1 byte integer &     SMD\_DTYPE\_INT8        \\ \hline
NC\_CHAR & ISO/ASCII character &      SMD\_DTYPE\_CHAR       \\ \hline
NC\_SHORT & signed 2 byte integer &   SMD\_DTYPE\_INT16          \\ \hline
NC\_INT & signed 4 byte integer &     SMD\_DTYPE\_INT32        \\ \hline
NC\_LONG & deprecated, but required for backward compatibility &    SMD\_DTYPE\_INT32         \\ \hline
NC\_FLOAT & single precision floating-point number &   SMD\_DTYPE\_FLOAT           \\ \hline
NC\_DOUBLE & double precision floating-point number &   SMD\_DTYPE\_DOUBLE          \\ \hline
NC\_UBYTE & unsigned 1 byte int &     SMD\_DTYPE\_UINT8        \\ \hline
NC\_USHORT & unsigned 2-byte int &    SMD\_DTYPE\_UINT16         \\ \hline
NC\_UINT & unsigned 4-byte int &   SMD\_DTYPE\_UINT32          \\ \hline
NC\_INT64 & signed 8-byte int &    SMD\_DTYPE\_INT64         \\ \hline
NC\_UINT64 & unsigned 8-byte int &    SMD\_DTYPE\_UINT64         \\ \hline
NC\_STRING & string &    SMD\_DTYPE\_STRING         \\ \hline
NC\_VLEN & used internally for vlen types &      NOT SUPPORTED YET       \\ \hline
NC\_OPAQUE & used internally for opaque types &     NOT SUPPORTED YET        \\ \hline
NC\_COMPOUND & used internally for compound types &    NOT SUPPORTED YET         \\ \hline
NC\_ENUM & used internally for enum types &       NOT SUPPORTED YET      \\ \hline \hline
\end{tabular}
\caption{\label{datatypes-netcdf} Data Types Support.}
\end{table}

\section{Compression}

The NetCDF-4 libraries inherit the capability for data compression from the HDF5 storage layer underneath the NetCDF-4 interface. Linking a program that uses NetCDF to a NetCDF-4 library allows the program to read compressed data without changing a single line of the program source code. Writing NetCDF compressed data only requires a few extra statements. And the nccopy utility program supports converting classic NetCDF format data to or from compressed data without any programming\footnote{Reference: \url{https://www.unidata.ucar.edu/blogs/developer/entry/netcdf_compression}}.

\subsection{ESDM}


ESDM does not support compression yet.
Because of that, all functions and tests related to chunking, deflate, and fletcher will not work when using ESDM.
We will integrate a compression library in the future and support quantification of error tolerance levels for different variables, but it was not yet integrated with the current version of ESDM. The Scientific Compression Library (SCIL) can be found in the following Git Repository:

\begin{center}
\url{https://github.com/JulianKunkel/scil/}
\end{center}

\section{Endianness}


The endianness is defined as the order of bytes in multi-byte numbers: numbers encoded in big endian have their most significant bytes written first, whereas numbers encoded in little endian have their least significant bytes first. Little-endian is the native endianness of the IA32 architecture and its derivatives, while big-endian is native to SPARC and PowerPC, among others\footnote{Reference: \url{https://www.gnu.org/software/guile/manual/html_node/Bytevector-Endianness.html}}.

ESDM only supports native-endianness of the machine it runs on.
The rationale behind this design choice is that ESDM will be deployed in data centers and will be used to store data optimally in the data center partitioned across available storage solutions.
It is not intended to be stored in a portable fashion, therefore, data can be imported/exported between, e.g., a NetCDF format and ESDM native format.

\subsection{ESDM}


ESDM only supports native-endianness of the machine it runs on. The developers believe that the native-endianness of the machine is enough for demonstrating the benefits of using ESDM to improve efficiency in the system.

\section{Groups}


NetCDF-4 files can store attributes, variables, and dimensions in hierarchical groups. This allows the user to create a structure much like a Unix file system. In NetCDF, each group gets an ncid. Opening or creating a file returns the ncid for the root group (which is named /). Dimensions are scoped such that they are visible to all child groups. For example, you can define a dimension in the root group, and use its dimension id when defining a variable in a sub-group. Attributes defined as NC\_GLOBAL apply to the group, not the entire file. The degenerate case, in which only the root group is used, corresponds exactly with the classic data mode, before groups were introduced\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/groups.html}}.

\subsection{ESDM}


In general, ESDM does not support groups from NetCDF. When only the root group is used, ESDM can work adequately and assumes the group and the file are the same entity.

The ability to work with groups is a functionality that ESDM developers may implement depending on future requirements.

\section{Fill Values}


Sometimes there are missing values in the data, and some value is needed to represent them. For example, what value do you put in a sea-surface temperature variable for points over land? In NetCDF, you can create an attribute for the variable (and of the same type as the variable) called \_FillValue that contains a value that you have used for missing data. Applications that read the data file can use this to know how to represent these values\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/fill_values.html}}.

\subsection{ESDM}


ESDM supports fill values. There are some speficic details in the implementation of fill values inside ESDM that worth noticing.

\tocheck

\section{Type Conversion}


Each NetCDF variable has an external type, specified when the variable is first defined. This external type determines whether the data is intended for text or numeric values, and if numeric, the range and precision of numeric values.

If the NetCDF external type for a variable is char, only character data representing text strings can be written to or read from the variable. No automatic conversion of text data to a different representation is supported. If the type is numeric, however, the NetCDF library allows you to access the variable data as a different type and provides automatic conversion between the numeric data in memory and the data in the NetCDF variable. For example, if you write a program that deals with all numeric data as double-precision floating-point values, you can read NetCDF data into double-precision arrays without knowing or caring what the external type of the NetCDF variables are. On reading NetCDF data, integers of various sizes and single-precision floating-point values will all be converted to double-precision, if you use the data access interface for double-precision values. Of course, you can avoid automatic numeric conversion by using the NetCDF interface for a value type that corresponds to the external data type of each NetCDF variable, where such value types exist.

The automatic numeric conversions performed by NetCDF are easy to understand, because they behave just like assignment of data of one type to a variable of a different type. For example, if you read floating-point NetCDF data as integers, the result is truncated towards zero, just as it would be if you assigned a floating-point value to an integer variable. Such truncation is an example of the loss of precision that can occur in numeric conversions.

Note that mere loss of precision in type conversion does not result in an error. For example, if you read double precision values into an integer, no error results unless the magnitude of the double precision value exceeds the representable range of integers on your platform. Similarly, if you read a large integer into a float incapable of representing all the bits of the integer in its mantissa, this loss of precision will not result in an error. If you want to avoid such precision loss, check the external types of the variables you access to make sure you use an internal type that has a compatible precision.

Converting from one numeric type to another may result in an error if the target type is not capable of representing the converted value. For example, an integer may not be able to hold data stored externally as an IEEE floating-point number. When accessing an array of values, a range error is returned if one or more values are out of the range of representable values, but other values are converted properly\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/data_type.html\#type_conversion}}.

The NC\_ERANGE error is returned by any of the reading or writing functions when one or more of the values read or written exceeded the range for the type. (For example if you were to try to read 1000 into an unsigned byte.) In the case of NC\_ERANGE errors, the NetCDF library completes the read/write operation, and then returns the error. The type conversion is handled like a C type conversion, whether or not it is within range. This may yield bad data, but the NetCDF library just returns NC\_ERANGE and leaves it up to the user to handle. (For more information about type conversion see Type Conversion)\footnote{Reference: \url{https://www.unidata.ucar.edu/software/netcdf/docs/group__error.html}}.

\begin{framed}

\tocheck

Whether a range error occurs in writing a large floating-point value near the boundary of representable values may be depend on the platform. The largest floating-point value you can write to a NetCDF float variable is the largest floating-point number representable on your system that is less than 2 to the 128th power. The largest double precision value you can write to a double variable is the largest double-precision number representable on your system that is less than 2 to the 1024th power.

\end{framed}

\subsection{ESDM}


ESDM supports most of the data conversions but may return a slightly different error.

ESDM deals with type conversion the same way as NetCDF. However, ESDM only accept conversions for attributes, and not for variables. The reason behind this choice is ...

\tocheck

\begin{comment}

Tests with ESDM conversion:

\begin{verbatim}

Final Results - INT8 to FLOAT

********************************************
INT8_MAX = 127
Maximum FLOAT = 126.000000
Maximum INT8 = 126
********************************************

********************************************
INT8_MIN = -128
Minimum FLOAT = -127.000000
Minimum INT8 = -127
********************************************

Final Results - INT16 to FLOAT

********************************************
INT16_MAX = 32767
Maximum FLOAT = 32766.000000
Maximum INT16 = 32766
********************************************

********************************************
INT16_MIN = -32768
Minimum FLOAT = -32767.000000
Minimum INT16 = -32767
********************************************

Final Results - INT32 to FLOAT

********************************************
INT32_MAX = 2147483647
Maximum FLOAT = 2147483520.000000
Maximum INT32 = 2147483583
********************************************

********************************************
INT32_MIN = -2147483648
Minimum FLOAT = -2147483520.000000
Maximum INT32 = -2147483583
********************************************

Final Results - INT64 to FLOAT

********************************************
INT64_MAX = 9223372036854775807
Maximum FLOAT = 9223371487098961920.000000
Maximum INT64 = 9223371761976865807
********************************************

********************************************
INT64_MIN = -9223372036854775808
Minimum FLOAT = -9223371487098961920.000000
Minimum INT64 = -9223371761976865808
********************************************

Final Results - UINT8 to FLOAT

********************************************
UINT8_MAX = 255
Maximum FLOAT = 254.000000
Maximum UINT8 = 254
********************************************

Final Results - UINT16 to FLOAT

********************************************
UINT16_MAX = 65535
Maximum FLOAT = 65534.000000
Maximum UINT16 = 65534
********************************************

Final Results - UINT32 to FLOAT

********************************************
UINT32_MAX = 4294967295
Maximum FLOAT = 4294967040.000000
Maximum UINT32 = 4294967167
********************************************

Final Results - UINT64 to FLOAT

********************************************
UINT64_MAX = 18446744073709551615
Maximum FLOAT = 18446742974197923840.000000
Maximum UINT64 = 18446743523953731615
********************************************

Final Results - INT8 to DOUBLE

********************************************
INT8_MAX = 127
Maximum DOUBLE = 126.000000
Maximum INT8 = 126
********************************************

********************************************
INT8_MIN = -128
Minimum DOUBLE = -127.000000
Minimum INT8 = -127
********************************************

Final Results - INT16 to DOUBLE

********************************************
INT16_MAX = 32767
Maximum DOUBLE = 32766.000000
Maximum INT16 = 32766
********************************************

********************************************
INT16_MIN = -32768
Minimum DOUBLE = -32767.000000
Minimum INT16 = -32767
********************************************

Final Results - INT32 to DOUBLE

********************************************
INT32_MAX = 2147483647
Maximum DOUBLE = 2147483646.000000
Maximum INT32 = 2147483646
********************************************

********************************************
INT32_MIN = -2147483648
Minimum DOUBLE = -2147483647.000000
Minimum INT32 = -2147483647
********************************************

Final Results - INT64 to DOUBLE

********************************************
INT64_MAX = 9223372036854775807
Maximum DOUBLE = 9223372036854774784.000000
Maximum INT64 = 9223372036854775295
********************************************

********************************************
INT64_MIN = -9223372036854775808
Minimum DOUBLE = -9223372036854774784.000000
Minimum INT64 = -9223372036854775295
********************************************

Final Results - UINT8 to DOUBLE

********************************************
UINT8_MAX = 255
Maximum DOUBLE = 254.000000
Maximum UINT8 = 254
********************************************

Final Results - UINT16 to DOUBLE

********************************************
UINT16_MAX = 65535
Maximum DOUBLE = 65534.000000
Maximum UINT16 = 65534
********************************************

Final Results - UINT32 to DOUBLE

********************************************
UINT32_MAX = 4294967295
Maximum DOUBLE = 4294967294.000000
Maximum UINT32 = 4294967294
********************************************

Final Results - UINT64 to DOUBLE

********************************************
UINT64_MAX = 18446744073709551615
Maximum DOUBLE = 18446744073709549568.000000
Maximum UINT64 = 18446744073709550591
********************************************

\end{verbatim}

About conversion...

Actually that is what happens:
      if (nc_def_var(ncid, VAR1_NAME, NC_BYTE, 1, dimids, &varid)) ERR;
      if (nc_enddef(ncid)) ERR;
      if (nc_put_var_uchar(ncid, varid, uchar_out) != NC_ERANGE) ERR;

I found this in the documentation:
> BUT netcdf library returns NC_BYTE data as 8-bit signed
> integers (instead of 8-bit unsigned integers)
> so that NC_BYTE values go from 0 to 127 and then from -128 to -1
> instead of going from 0 to 255 as wanted.

That explains it, right?
https://www.unidata.ucar.edu/software/netcdf/docs_rc/group__variables.html#gac6e82a7c808f1e3c895616415ffa8e5d

The shit function assumes we convert the variable data *on the fly* while writing to the file…

As we are not converting the data type or anything here, we are not supporting this.
I reckon, we should check for any function which NC type does not match our expected type, write an error and abort.
I’m not intending to support this (ever)...

LR. Was this not the point of having the conversion inside smd? At least between the types we support? I also checked something in the documentation and they don’t do it between char and numbers.

The difference is that one is for ATTRIBUTES and one for VARIABLES, SMD is not involved in VARIABLES and hopefully never be as this is a performance problem.
We *might* be able to do part of this, in case COMPRESSION is turned on, as we then have to do a conversion anyway!
Document it this way.

\end{comment}

\begin{comment}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{NetCDF ERROR} & \multicolumn{1}{|c|}{Description} & \multicolumn{1}{|c|}{ESDM ERROR} \\ \hline\hline
NC\_EBADDIM                   &  Invalid dimension id or name.                                                      &      \\ \hline
NC\_EBADNAME                  &  Attribute or variable name contains illegal characters.                            &      \\ \hline
NC\_EHDFERR                   &  Error at HDF5 layer.                                                               &      \\ \hline
NC\_EINDEFINE                 &  Operation not allowed in define mode.                                              &      \\ \hline
NC\_EINVAL                    &  Invalid Argument.                                                                  &      \\ \hline
NC\_ELATEFILL                 &  Attempt to define fill value when data already exists.                             &      \\ \hline
NC\_ENOTINDEFINE              &  Operation not allowed in data mode.                                                &      \\ \hline
NC\_ENOTVAR                   &  Variable not found.                                                                &      \\ \hline
NC\_EPERM                     &  Write to read only.                                                                &      \\ \hline
NC\_ERANGE                    &  Math result not representable.                                                     &      \\ \hline
NC\_FILL\_FLOAT               &  Default fill value.                                                                &      \\ \hline
NC\_FORMAT\_64BIT\_OFFSET     &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_CLASSIC           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4           &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
NC\_FORMAT\_NETCDF4\_CLASSIC  &  Format specifier for nc\_set\_default\_format() and returned by nc\_inq\_format.   &      \\ \hline
\hline
\end{tabular}
\caption{Conversion between ESDM and NetCDF4 Errors.}
\end{table}

\end{comment}
